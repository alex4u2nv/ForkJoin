package com.swazzy.computer;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.RecursiveTask;

import org.apache.log4j.Logger;

import com.swazzy.model.Data;
import com.swazzy.model.Result;
import com.swazzy.service.Calculator;
/**
 * ForkJoin Forks the data out into various threads for calculations.
 * @author Alexander D. Mahabir 
 * @version $Revision: $:
 * @date 	$Date: $:
 * $Id: $:
 * Spring Framework, PriorityQueue, ForkJoin, Concurrency
 */
public class ForkJoinComputer extends RecursiveTask<Result> {
	/**
	 * 
	 */
	private static final long serialVersionUID = 3516672838786489490L;
	static Logger log = Logger.getLogger(ForkJoinComputer.class);
	private BlockingQueue<Data> blockingQueue = null;
	private final Calculator calculator;
	List<Result> results;
	final private Data data;
	public List<Result> getResults() {
		return results;
	}

	/**
	 * 
	 * @param blockingQueue
	 */
	public ForkJoinComputer(BlockingQueue<Data> blockingQueue,
			Calculator calculator) {
		this.blockingQueue = blockingQueue;
		this.data = null;
		this.calculator = calculator;
		log.trace("Constructed FJ computer with blockingQueue of size: "
				+ blockingQueue.size());
		results = new LinkedList<Result>();
	}
	/**
	 * 
	 * @param data
	 */
	public ForkJoinComputer(Data data, Calculator calculator){
		this.data=data;
		this.calculator=calculator;
		log.trace("Constructed FJ computer with Data: " + data);
		results=null;
	}
	/**
	 * Generate the Summation Worker
	 */
	private ForkJoinComputer getSummationWorker(Data data) {
		final Calculator _calculator = calculator;
		ForkJoinComputer fjw = new ForkJoinComputer(data, new Calculator() { 
			
			@Override public Result calculateSum(Data data) {	return null;}
			@Override public Result calculateProduct(Data data) {return null;}
			@Override public Result calculateFibonacci(int n) {return null;}
			@Override public Result add(Result result01, Result result02) {return null;}
			@Override
			public Result calculate(Data data) {
				return _calculator.calculateSum(data);
			}
		});
		return fjw;
	}
	/**
	 * Generate the Product calculation worker
	 * @param data
	 * @return
	 */
	private ForkJoinComputer generateProductWorker(Data data) {
		final Calculator _calculator = calculator;
		ForkJoinComputer fjw = new ForkJoinComputer(data, new Calculator() { 
			
			@Override public Result calculateSum(Data data) {	return null;}
			@Override public Result calculateProduct(Data data) {return null;}
			@Override public Result calculateFibonacci(int n) {return null;}
			@Override public Result add(Result result01, Result result02) {return null;}
			@Override
			public Result calculate(Data data) {
				return _calculator.calculateProduct(data);
			}
		});
		return fjw;
	}
	/**
	 * Generate the Fibonacci Calculation worker
	 * @param data
	 * @return
	 */
	private ForkJoinComputer generateFibonacciWorker(Data data) {
		final Calculator _calculator = calculator;
		ForkJoinComputer fjw = new ForkJoinComputer(data, new Calculator() { 
			
			@Override public Result calculateSum(Data data) {	return null;}
			@Override public Result calculateProduct(Data data) {return null;}
			@Override public Result calculateFibonacci(int n) {return null;}
			@Override public Result add(Result result01, Result result02) {return null;}
			@Override
			public Result calculate(Data data) {
				int n = Integer.parseInt(data.getId().toString());
				if (data.getId() <= 1)
					return _calculator.calculateFibonacci(n);

				ForkJoinComputer fjwComputer = generateFibonacciWorker(data);
				fjwComputer.fork();
				return _calculator.add(_calculator.calculateFibonacci(n - 1),
						fjwComputer.join());

			}
		
		});
		return fjw;
	}

	/**
	 * Perform Computation. The first level of computation takes the problem,
	 * and forks the tasks out into various workers that are generated by the
	 * generateXXXWorker above.
	 */
	@Override
	protected Result compute() {
		if (blockingQueue != null) {
			List<ForkJoinComputer> workers = new LinkedList<ForkJoinComputer>();

			while (blockingQueue.size() > 0) {
				Data data = blockingQueue.poll();
				ForkJoinComputer fjws = this.getSummationWorker(data);
				fjws.fork();
				workers.add(fjws);
				ForkJoinComputer fjwp = this.generateProductWorker(data);
				fjwp.fork();
				workers.add(fjwp);

				ForkJoinComputer fjwf = this.generateProductWorker(data);
				fjwf.fork();
				workers.add(fjwf);
			}
		}
		return this.calculator.calculate(data);
	}
}
